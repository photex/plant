#!/usr/bin/guile \
--no-auto-compile -e main -s
!#

(use-modules (ice-9 pretty-print))

(define (join-path . args)
  (string-join args "/"))

(define (curpath p)
  "simply join the path fragment with the current working directory"
  (join-path (getcwd) p))

;; globals

(define *plant-lisp* (or (getenv "PLANT_LISP") "sbcl"))
(format #t "PLANT_LISP = ~a~%" *plant-lisp*)

;;; Plant home is where we'll be looking for 
(define *plant-home* (or (getenv "PLANT_HOME") (join-path (getenv "HOME") ".plant")))
(format #t "PLANT_HOME = ~a~%" *plant-home*)

;;; This is the file that holds the specific command line arguments for the
;;; supported lisp implementations.
(define *lisp-settings* '())

(define *plant-project* (curpath "plant-project.scm"))
(define *plant-project-dir* (curpath ".plant"))
(define *deps-dir* (join-path *plant-project-dir* "deps"))

(define *project-data* '())

(define *quicklisp-url* "http://beta.quicklisp.org/quicklisp.lisp")

;; utilities

(define (path-test op p)
  "wraps the test command."
  (equal? 0 (system (string-join
                     (list "test" op p)))))

(define (file? f)
  "Returns true if 'f' is a valid path to a file."
  (path-test "-f" f))

(define (dir? d)
  "Returns true if 'd' is a valid path to a directory."
  (path-test "-d" d))

(define (project-item item-key)
  (assoc-ref *project-data* item-key))

(define (project-name)
  (project-item #:project-name))

(define (project-lisp)
  (join-path *plant-project-dir*
             (format #f "~a-~a" *plant-lisp* (project-name))))

(define (no-user-init)
  (assoc-ref *lisp-settings* #:no-user-init))

(define (load-arg arg)
  (string-join (list (assoc-ref *lisp-settings* #:load) arg)))

(define (eval-arg arg)
  (string-join (list (assoc-ref *lisp-settings* #:eval) arg)))

(define (save)
  (format #f (assoc-ref *lisp-settings* #:save)
          (project-lisp)))

(define (project-quickloads)
  (project-item #:quickloads))

;; functions

(define (save-project-settings)
  (with-output-to-file *plant-project*
    (lambda ()
      (pretty-print *project-data* (current-output-port)))))

(define (load-project-settings)
  (with-input-from-file *plant-project*
    (lambda ()
      (set! *project-data* (read (current-input-port))))))

(define (install-quicklisp)
  (let ((wget-cmd (string-join (list "wget" *quicklisp-url*)))
        (quicklisp-install-cmd (string-join
                                (list *plant-lisp* (no-user-init)
                                      (load-arg "quicklisp.lisp")
                                      (eval-arg "'(quicklisp-quickstart:install :path #P\"~/.plant/quicklisp/\")'")
                                      (eval-arg "'(quit)'")))))
    (system wget-cmd)
    (system quicklisp-install-cmd)
    (delete-file "quicklisp.lisp")))

(define (build-lisp options)
  (let* ((quickloads-fmt (string-join (map (lambda (x) (format #f ":~a" x))
                                       (append (project-quickloads) options))))
         (quickloads-arg (string-join
                          (list "'(ql:quickload (list" quickloads-fmt "))'")
                          )))
    (unless (dir? *plant-project-dir*)
      (mkdir *plant-project-dir*))
    
    (system (string-join
             (list *plant-lisp* (no-user-init)
                   (load-arg "~/.plant/quicklisp/setup.lisp")
                   (load-arg "~/.plant/setup.lisp")
                   (eval-arg quickloads-arg)
                   (eval-arg (save)))))))

;; commands

(define (help options)
  (format #t "plant setup~%")
  (format #t "plant include <git|hg|wget> <url>~%")
  (format #t "plant quickloads <system> [<system> <system> ...]~%")
  (format #t "plant run [--swank [port]]~%")
  (format #t "plant rebuild~%"))

(define (setup options)
  ;; TODO perhaps check and see if the lisp wasn't already saved?
  (build-lisp options))

(define (quickloads options)
  (if (>= (length options) 1)
      (begin
        (build-lisp options)
        (set! *project-data*
              (assoc-set! *project-data* #:quickloads
                          (append (assoc-ref *project-data* #:quickloads)
                                  options)))
        (save-project-settings))
      (help options)))

(define (run options)
  (let* ((option-count (length options))
         (swank? (equal? "--swank" (when (>= option-count 1)
                                       (car options))))
         (default-port "4005")
         (port (if (and swank? (>= option-count 2))
                   (cadr options)
                   default-port))
         (swank-arg-template "'(swank:create-server :dont-close t :port ~a)'")
         (swank-args (eval-arg (format #f swank-arg-template port)))
         (cmd-line (string-join (list (project-lisp)
                                      (no-user-init)
                                      (if swank?
                                          swank-args
                                          "")))))
    (if (file? (project-lisp))
        (system cmd-line)
        (begin
          (format #t "ERROR: The current directory does not appear to be a plant project.~%~a~%~a~%"
                  (project-lisp) cmd-line)
          (exit 2)))
    ))

(define (include options) #f)

;; entry point

(define (main args)
  (format #t "~%")
  
  ;; we need at least a command
  (when (< (length args) 2)
    (help '())
    (exit 255))

  ;; Load the settings for the requested lisp
  (let* ((lisp-settings-file (join-path *plant-home* "lisp-settings.scm"))
         (settings-data (with-input-from-file lisp-settings-file (lambda () (read (current-input-port)))))
         (aliases (map (lambda (config)
                         (list (assoc-ref (cdr config) #:aliases)
                               (car config)))
                       settings-data))
         (desired-lisp #f))
    (map (lambda (alias)
           (when (member *plant-lisp* (car alias))
             (set! desired-lisp (cadr alias))))
         aliases)
    (if (not desired-lisp)
      (begin
        (help '())
        (format #t "~%ERROR: ~a is not currently supported by plant.~%" *plant-lisp*)
        (exit 2))
      (begin
        (format #t "Using settings for ~a~%" desired-lisp)
        (set! *lisp-settings* (assoc-ref (assoc-ref settings-data desired-lisp) #:settings)))))

  (unless *lisp-settings*
    (format #t "~%ERROR: Unable to load settings for the current lisp.~%")
    (exit 3))

  ;; are we setting up a new project or loading a previously created one
  (if (not (file? *plant-project*))
      ;; Initialize the project data
      (begin
        (format #t "Unable to locate a project file (~a) creating a new one.~%" *plant-project*)
        (let* ((project-defaults-file (join-path *plant-home* "project-defaults.scm"))
               (project-name (basename (getcwd)))
               (lisp-settings (with-input-from-file (join-path *plant-home* "lisp-settings.scm")
                                (lambda () (read (current-input-port))))))
          ;; Load the defaults and add/update values for the current project
          (set! *project-data* (with-input-from-file project-defaults-file
                                 (lambda () (read (current-input-port)))))
          (set! *project-data* (assoc-set! *project-data* #:project-name project-name)))
        (save-project-settings))
      ;; else load the existing project data and bind it
      (load-project-settings))

  (unless (dir? (join-path (getenv "HOME") ".plant" "quicklisp"))
    (install-quicklisp))

  (unless (defined? '*project-data*)
    (format #t "~%ERROR: Unable to load or create project data!~%")
    (exit 3))
  
  (let* ((command (cadr args))
         (options (cddr args)))
    ;; dispatch further work to the individual command handlers
    (cond ((equal? command "run") (run options))
          ((equal? command "quickloads") (quickloads options))
          ;; ((equal? command "include") (include options))
          ((equal? command "setup") (setup options))
          ((equal? command "help") (help options))
          (#t (begin
                (help options)
                (format #t "~%ERROR: Unknown command ~a~%" command))))))
