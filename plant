#!/usr/bin/guile \
--no-auto-compile -e main -s
!#

;; utilities

(define (curpath p)
  "simply join the path fragment with the current working directory"
  (string-join (list (getcwd) p) "/"))

(define (path-test op p)
  "wraps the test command."
  (equal? 0 (system (string-join
                     (list "test" op (curpath p))))))

(define (file? f)
  "Returns true if 'f' is a valid path to a file."
  (path-test "-f" f))

(define (dir? d)
  "Returns true if 'd' is a valid path to a directory."
  (path-test "-d" d))

;; globals

(define *default-quickloads* '("swank" "alexandria"))
(define *plant-project* (curpath "plant.scm"))
(define *plant-dir* (curpath ".plant.d"))
(define *project-data*)

(define *quicklisp-url* "http://beta.quicklisp.org/quicklisp.lisp")

;; functions

(define (install-quicklisp options)
  (system (string-join (list "wget" *quicklisp-url*)))
  (let ((plant-lisp (assoc-ref *project-data* #:plant-lisp))
        (no-user-init (assoc-ref *project-data* #:no-user-init))
        (load (assoc-ref *project-data* #:load))
        ()))
  (system (string-join (list (assoc-ref *project-data* #:plant-lisp)
                             (assoc-ref *project-data*) LOAD "quicklisp.lisp"
                             EVALSTR "'(quicklisp-quickstart:install :path #P\".plant/quicklisp/\")'"
                             EVALSTR "'(quit)'")))
  (delete-file "quicklisp.lisp"))

(define (build-lisp options)
  (let ((quickloads (string-join (map (lambda (x)
                                        (format #f ":~a" x)) options))))
    (when (not (dir? ".plant"))
      (mkdir ".plant"))
    (system (string-join
             (list PLANT_LISP NOUSERINIT LOAD ".plant/quicklisp/setup.lisp"
                   LOAD "~/.plant/setup.lisp"
                   EVALSTR (string-join
                            (list "'(ql:quickload '\"'\"'(:swank :alexandria "
                                  quickloads
                                  "))'"))
                   EVALSTR SAVE)))))

;; commands

(define (help options)
  (format #t "plant init~%")
  (format #t "plant include <git|hg|wget> <url>~%")
  (format #t "plant quickloads <system> [<system> <system> ...]~%")
  (format #t "plant run [--swank [port]]~%")
  (format #t "plant rebuild~%"))

(define (init options)
  (install-quicklisp options)
  (build-lisp options))

(define (quickloads options)
  (if (>= (length options) 1)
      (build-lisp options)
      (help options)))

(define (run options)
  (let* ((option-count (length options))
         (plant (format #f ".plant/~a-~a" PLANT_LISP *project-name*))
         (swank? (equal? "--swank" (when (>= option-count 1)
                                       (car options))))
         (default-port "4005")
         (port (if (>= option-count 2)
                   (cadr options)
                   default-port))
         (swank-arg-template "'(swank:create-server :dont-close t :port ~a)'")
         (swank-args (string-join
                      (list EVALSTR (format #f swank-arg-template port))))
         (cmd-line (string-join (list plant NOUSERINIT
                                      (if swank?
                                          swank-args
                                          "")))))
    (if (file? plant)
        (system cmd-line)
        (begin
          (format #t "ERROR: The current directory does not appear to be a plant project.")
          (exit 2)))))

(define (rebuild options) #f)

(define (include options) #f)

;; entry point

(define (main args)
  "There isn't much here. We just take the command and the options and run."

  ;; we need at least a command
  (when (< (length args) 2)
    (help '())
    (exit 255))

  (if (not (file? *plant-project*))
      ;; load the default configurations for supported lisps
      ;; and initialize the project data
      (begin
        (let* ((plant-lisp (or (getenv "PLANT_LISP") "sbcl"))
               (project-defaults-file (format #f "~a/.plant/~a-defaults.scm"
                                              (getenv "HOME") plant-lisp))
               (project-name (basename (getcwd))))
          ;; If there is no defaults file for the current lisp then we bail
          (unless (file? project-defaults-file)
            (help '())
            (format #t "ERROR: ~a is not currently supported by plant.~%" plant-lisp)
            (exit 2))
          ;; Load the defaults and add/update values for the current project
          (primitive-load project-defaults-file)
          (assoc-set! plant-default-config #:project-name project-name)
          (assoc-set! plant-default-config #:plant-lisp plant-lisp)
          (assoc-set! plant-default-config #:quickloads *default-quickloads*)
          (assoc-set! plant-default-config
                      #:save (format #f (assoc-ref plant-default-config #:save)
                                     plant-lisp project-name))
          (set! *project-data* project-data)))
      ;; else load the existing project data and bind it
      (begin
        (primitive-load *plant-project*)))

  (unless (defined? *project-data*)
    (format #t "ERROR: Unable to load or create project data!")
    (exit 3))
  
  (let* ((command (cadr args))
         (options (cddr args)))
    ;; dispatch further work to the individual command handlers
    (cond ((equal? command "run") (run options))
          ((equal? command "quickloads") (quickloads options))
          ((equal? command "update") (rebuild options))
          ((equal? command "include") (include options))
          ((equal? command "init") (init options))
          ((equal? command "help") (help options))
          (#t (help options)))))
